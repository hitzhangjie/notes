协议相关问题：

0、version，协议版本号的问题，pb本身是可扩展的，版本号升级后对老服务没影响，使用老协议版本的服务A请求使用新协议版本的服务B，B可能会丢失某些协议头细节，这个时候应该直接通告调用方版本不一致？还是继续逻辑处理；

1、call_type: 

- 之前我们一些框架实现都是放在client这里来实现的，client关心结果的时候，就可以接收响应，不关心的时候就只发不收，因为请求体里面没有call_type，服务端是统一都要回包处理的，单向请求的时候，服务端回包没有意义，所以我觉得这里的call_type这么看来是可以让服务端更优雅地处理这种单向请求的问题；
- 接着上面这点讨论，服务端是否可以不回包，如果请求处理失败的情况下，是否可以不回包通知调用方，调用方忽略这里的失败是否合理，在能力上我们可以支持，但是现实使用的过程中，这样的场景是否应该被鼓励。
- call_type现在是放在请求体中的，有了它客户端、服务端可以配合地很灵活，这个字段我觉得应该没问题的。

2、stream_id、request_id与repeated bytes data的关系：

- 如果是普通请求、单向请求，那么是否只有request_id、data中只有一个请求体？
- 如果是流式请求，那么是否只有stream_id、data中包含多个请求体，每个请求体没有seqno，服务端如何回包，http1.x pipeline的形式？还是http 2.x streaming的形式（那seqno放在哪里？）

3、timeout，我们现在用的框架一般是client端设置超时时间来决定后端处理是否超时，假如client0请求server1，server1又串行请求server2、3、4，按我们现有的一些框架可能会根据server1的平均处理时长（如2s）来告知client0清把超时时间设为2s+。

client当然可能会设置的很大，比如10s，那么服务端是以调用方超时时间10s为准，还是以后端反馈的超时时间2s+2s+2s为准，如果调用方能容忍更大的超时时间，服务端为什么不处理呢？感觉参考调用方超时时间是合理的，并且这个超时时间要一直透传给后续的各种后端请求。

> 对服务端有什么影响？并发量大的时候，client请求超时时间过大，server1可能导致过多的goroutine阻塞在io上，如某个后端server2响应就是慢，server2扩容是必须的。问题是调用方误设置的超时时间就可以导致server1耗费的资源上涨，这个值得考虑下，server1当然可以限制并发连接数。

4、Caller、callee，这个不管是用于日志流水、还是分布式跟踪，都是不够的，先看分布式跟踪，至少还需要traceid、spanid，可以在trans_info<traceContext>中透传traceContext。trace的数据基本用不到协议头中的caller、callee信息，span里面设置就可以。这里的caller、callee、func意义何在？

   caller请求callee的时候自然也知道要请求的是谁，请求到达callee的时候被调方当然知道自己是谁，caller还可以在用于业务代码中区分上游是谁，callee的作用是什么呢？

5、message_type：调用链信息这个trace层直接上报给trace backend就可以，traceContext可以连通rpc请求体一起发送，分开发送有问题吧，假如因为时序问题，服务端收到正常请求已经开始处理了，但是traceContext还没发过来这怎么搞呢？

```go
syntax = "proto3";

package trpc;

// 请求协议头
message RequestProtocol {
  // 协议版本
  uint32      version                   		= 1; 
  
  // 请求的调用类型
  // 比如: 普通调用，单向调用，流式调用
  uint32      call_type                 		= 2;
  
  // 流id
  uint32    stream_id                   		= 3;
  
  // 请求唯一id
  uint32    request_id                  		= 4;
  
  // 请求的超时时间，单位ms
  uint32    timeout                     		= 5;
  
  // 主调服务的名称
  string    caller                      		= 6;
  
  // 被调服务的路由名称
  // 规范格式，trpc.应用名.服务名.pb的service名
  string    callee                      		= 7;
  
  // 调用服务的接口名
  // 规范格式，pb idl定义的接口名
  string    func                        		= 8;
  
  // 框架信息透传的消息类型
  // 比如调用链、染色key、灰度、鉴权、流结束、多环境等的标识
  uint32    message_type                	= 9;
  
  // 框架透传的信息key-value对，目前分两部分
  // 1是框架层要透传的信息，key的名字要以trpc_开头
  // 2是业务层要透传的信息，业务可以自行设置，严禁key的名称开头使用trpc
  map<string, string> trans_info        = 10;
  
  // 请求数据的数据类型
  // 比如: proto/jce/json, 默认proto
  uint32    content_type                	= 11;
  
  // 请求数据使用的压缩方式
  // 比如: gzip/snappy/..., 默认不使用
  uint32    content_encoding            	= 12;
  
  // 二进制数据
  optional  bytes data                  	= 99;
}

// 响应协议头
message ResponseProtocol {
  // 协议版本
  uint32      version                   		= 1; 
  
  // 请求的调用类型
  // 比如: 普通调用，单向调用，流式调用
  uint32      call_type                 		= 2;
  
  // 流式id
  uint32    stream_id  			        = 3;
  
  // 请求唯一id
  uint32    request_id                 	 	= 4;
  
  // 请求在框架层的错误返回码
  int32    ret                          			= 5;
  
  // 接口的错误返回码
  // 建议业务在使用时，标识成功和失败，0代表成功，其它代表失败
  int32    func_ret                     		= 6;
  
  // 调用结果信息描述
  // 失败的时候用
  string    error_msg                   		= 7;
  
  // 框架信息透传的消息类型
  // 比如调用链、染色key、灰度、鉴权、流结束、多环境等的标识
  uint32    message_type                	= 8;
  
  // 框架透传回来的信息key-value对，
  // 目前分两部分
  // 1是框架层透传回来的信息，key的名字要以trpc_开头
  // 2是业务层透传回来的信息，业务可以自行设置，严禁key的名称开头使用trpc
  map<string, string> trans_info        = 9;
  
  // 响应数据的编码类型
  // 比如: proto/jce/json, 默认proto
  uint32    content_type                	= 10;
  
  // 响应数据使用的压缩方式
  // 比如: gzip/snappy/..., 默认不使用
  uint32    content_encoding            	= 11;
  
  // 二进制数据
  optional  bytes data                  	= 99;
}
```

