### Spring Cloud Eureka：服务注册发现

- 服务提供者
  - 服务注册，服务注册到注册中心
  - 服务同步，多个注册中心之间同步
  - 服务续约，服务向注册中心续约
- 服务消费
  - 获取服务，服务从注册中心获取服务清单，并每隔30s更新一次
  - 服务调用，服务消费者从清单中根据服务名，获取服务实例列表，并通过负载均衡决定请求哪个服务
  - 服务下线，服务下线的时候通知注册中心我要下线了

- 服务注册中心
  - 失效剔除，注册中心每隔60s剔除没有续约的服务，可以避免服务异常挂掉没有正常”下线“的问题
  - 自我保护，注册中心为每个实例维护一个心跳连接，15分钟内超过85%的实例出现心跳丢失，就会触发自我保护机制，将实例注册信息保护起来，不让其过期



### Spring Cloud Ribbon：客户端负载均衡

- 服务端负载均衡

  - 硬件：在服务节点之间安装专门用于负载均衡的设备，如F5等；

  - 软件：在服务器上安装一些具有负载均衡功能或模块的软件来完成请求分发工作，比如Nginx等；

    ```bash
    
                        /--> 服务A
    客户端 --> 负载均衡设备 --> 服务B
    										\--> 服务C
    
    ```

- 客户端负载均衡

  - 自己维护服务清单列表，这些列表来自于服务注册中心
  - 客户端通过负载均衡算法，来决定下次请求哪个服务实例

  

ribbon实现了客户端负载均衡

**大致实现：**

	- 服务实例ip列表+动态更新
	- ping，检测服务实例是否在线等等
	- strategy，选择下一个请求的服务实例

**负载均衡策略：**

- Random，随机选一个

- RoundRobin，轮询

- Retry，重试，失败几次后返回失败

- WeightedResponseTime，

  当前权重+所有服务实例响应时间之和-某实例平均响应时间，

  这样划分权重区间，选个随机数看落在哪个区间，权重区间越大的，对应的实例更容易被选中，

- BestAvailable，根据实例的统计数据，如请求数、连接数等等，选择一个最空闲的，

- Predicate

- AvailabilityFiltering，先过滤清单，再轮询选择



**Eureka VS Zookeeper**

- Eurreka，强调CAP中的AP（可用性+分区耐受性），

- Zookeeper，强调CAP的CP（一致性+分区耐受性），

  **Eureka宁可接受有故障的节点，也不愿意丢掉健康的节点~~权衡！****当然如果碰到了故障节点时，客户端通过重试来解决！**

  自我保护，注册中心为每个实例维护一个心跳连接，15分钟内超过85%的实例出现心跳丢失，就会触发自我保护机制，将实例注册信息保护起来，不让其过期。



### Spring Cloud Hystrix：故障保护

- 服务降级
- 服务熔断，故障、失败等掐掉流量，避免故障继续扩散
- 线程隔离
- 信号隔离
- 请求缓存
- 请求合并
- 服务监控



### Spring Cloud Feign：声明式服务调用



### Spring Cloud Zuul：API网关服务

API网关是一个更为智能的应用服务器，它的定义类似于面向对象设计模式中的facade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。它除了要实现请求路由、负载均衡、校验过滤等功能之外，还需要更多能力，比如与服务治理框架的结合、请求转发时的熔断机制、服务的聚合等一系列高级功能。



### Spring Cloud Config：分布式配置中心



