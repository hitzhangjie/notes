top里面load average，分别表示最近1分钟、5分钟、10分钟的`正在运行的进程`以及处于`不可中断等待状态`的进程数量。

top里面硬件中断%hi，软中断%si，硬件中断处理程序一般分两步：顶半部+底半部。

- 顶半部，一般是处理硬件端口上的数据收发，如网卡收包；
- 底半部，一般是硬件处理完之后，后面继续不紧急的处理，如从网卡收包后继续交给解包处理。

top中nice值%ni表示的是低优先级进程占用cpu调度的时间百分比。

signal，kill信号，9-SIGKILL，19-SIGSTOP，这两个信号进程不允许通过signal()来捕获。 

线程是clone系统调用创建出来的，线程用进程的栈空间来跑，线程就是一个轻量级进程LWP。

ps aux -L，这个-L参数可以看到线程。

mpstat

sar，系统活动报告，/var/log/sar/saXX，tnm2，sar是查看系统状态的瑞士军刀。

perf top，[k]开头的是内核函数。

pidstat，

/proc/cpuinfo，physical id：物理cpu，core id：物理核，一个物理核可能开超线程怎么看呢？sibling如果为1则表示没有开超线程，如果sibling!=1则表示开了超线程。

numa，本地node节点内存不够用了，可以用另一个node节点的内存。node（cpu+内存构成一个node）。

多队列网卡，驱动里面会为每个队列注册一个中断向量，多个队列的中断会注册到不同的cpu核心上去处理。

cat /proc/interrupts，检查cpu核心上注册的中断。

cat /proc/irq/$中断号/smp_affinity，这个文件中内容为3，是表示的掩码11，表示第2个和第3个核心都可以处理该中断号。

网卡队列RPS和RFS，如果网卡这个硬件的网卡队列数不够，可以打开虚拟的网卡队列RPS和RFS，就是网卡中断服务程序底半部中将收到的数据丢到多个队列。cat /sys/class/net/eth1/queues/rx-0/rps_cpus，这个文件中内容如果全是1，表示让内核自己轮询，其实也是掩码的形式，如果为0就是0号核心来处理。

nice值越小，优先级越高，取值范围为[-20,20)，priority（ps里面的PR字段）取值范围为[0,-140)，但是只允许用其中？个，其他给实时进程使用。

nice为0，对应着PR为20，nice为-10，PR为10。但是也可能对应方式不同，不管怎么对应。PR、nice都是值越低，优先级越高。



chrt，改变实时进程的调度方式。

SCHED_OTHER：指的就是CFS。最低优先级的实时进程都比普通进程的优先级高。

用的比较多的调度器：O1、CFS。

11111111111111111111111111111111111111111111111111111111111111111111111111111111

调度算法：CFS

CFS：完全公平的调度算法，比如10个进程在1s中内完全公平调度，即每个进程1s内得到0.1s的调度。

实现方法：

数据结构：红黑树，节点key：进程运行的事件，优先调度左子树叶子节点。

问题：如何实现优先级，不用真正的运行时间，而是用虚拟时间，即使两个不同优先级的进程实际执行的时间相同，他们会乘以一个不同的系数，进程优先级高的乘的系数小，所以会得到更多的机会执行。当虚拟运行时间vruntime超过其他低优先级进程的vruntime的时候，低优先级就可以得到运行的机会了。

CFS的目标延时时间，多久调度一次，/prc/sys/kernel/sched_latency_ns这里面的值除以实时进程数量，时间单位ns。追求吞吐量就调高这个值，追求响应速度就调低这个值。还有一个值也会影响sched_migration_cost_ns。

nice：动态优先级，priority：静态优先级。内核看到的是priority，但是会根据nice来动态调整优先级，有一个上下浮动的范围，内核判断cpu消耗型的会调低优先级，io消耗型的会调高优先级。

cpu某个核心负载高，要将某个待调度进程迁移到其他cpu核心执行，迁移后会导致cache命中率降低，为了避免迁移后应用程序性能下降，需要考量cache命中率。/proc/sys/kernel//sched_migration_cost_ns，如果内核考量这个值大于该文件中配置的值就会迁移，这个值调更大可以减少迁移。甚至可以通过taskset将某个进程绑定到一个指定核心上一直执行。还有一个会影响到迁移/proc/sys/kernel/sched_nr_migrate。

进程组也会影响到部分调度，sched_autogroup_enabled这个配置可以将进程组也考虑在内。

111111111111111111111111111111111111111111111111111111111111111111111111111111

调度算法：调度算法O1+时间片

如何解决优先级问题：优先级高的时间片大一点。



111111111111111111111111111111111111111111111111111111111111111111111111111111

real != user+sys，user+sys是cpu占用时间，real是实际花费的事件，可能因为不可调度，比如find需要磁盘io占用一部分时间，这个时候进程会被阻塞一段时间，这段时间会计算到real里面。

也有可能user+sys>real，比如多线程程序在多个核上跑，cpu占用时间就大了。



/proc，这个虚拟文件系统



strace、ltrace、……

systemtap、dtrace、perf……



111111111111111111111111111111111111111111111111111111111111111111111111111111

cgroup

/sys/fs/cgroup

这个目录下面有些限制，比如磁盘限制blkio、内存限制memory、cpu限制cpuset等等。

磁盘限制也可以借助quota（配额）来控制，xfs文件系统内置了对不同用户、进程对磁盘使用空间的限制能力。

echo 0,1 > /sys/fs/cgroup/zhangjie/cpuset.cpus，绑定cpu核心运行后续创建的进程（需要借助cgexec），后续修改的话会动态迁移进程到其他核心运行。cpuset.cpus限制运行的核心，cpu.cfs_quota_...可以用来限制cpu核心的使用百分比，会均摊到每个核心的限制上。cgexec也可以组合多个限制条件如同时限制cpuset。cpu.shares还可以限制不同组（setsid）对cpu的占用比例。

 cgexec -g cpuset:zhangjie ${命令}



- 吞吐量：每单位时间完成的进程数目 * 周转时间：每个进程提出请求到运行完成的时间
- 响应时间：从提出请求到第一次回应的时间



