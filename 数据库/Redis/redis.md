# Redis介绍

Redis是一种“**内存数据库**”，作为“**分布式缓存**”组件选型的可选项之一，我认为开发者应该掌握Redis如何使用并了解其相关实现细节，因为Redis设计简单、性能优异，不仅仅可以拿来作为组件使用，也可以指导我们后续的软件架构设计。

这本书《Redis设计与实现 黄健宏》，作者以通俗易懂的语言、合理的文章脉络组织阐明了Redis的常用操作、命令实现以及涉及到的底层数据结构，从入门到精通的典范。此外对Redis集群的一些高阶特性也做了介绍，如Redis主从节点的全量同步、部分同步的实现，介绍了sentinel借助主节点心跳、其他sentinel节点判断主节点主观、客观离线的细节，以及sentinel leader选举，Redis主节点的重新选举等等。应该算是本不错的好书！作者也写了不少伪代码、示例，很用心！推荐一下！

![cover.png](assets/cover.png)

本书是在“**微信阅读**”这款app中阅读的，阅读过程中添加了不少阅读笔记，这里将觉得比较重要的一些点重新在这里梳理下，如果有需要的话，还是可以回到微信阅读中重新翻翻相关的章节来确认下细节。

# Part 1 数据结构

## 1.1 简单动态字符串

Redis key底层数据结构bds

\>> 通过使用SDS而不是C字符串，Redis将获取字符串长度所需的复杂度从O（N）降低到了O（1），这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。例如，因为字符串键在底层使用SDS来实现，所以即使我们对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响，因为STRLEN命令的复杂度仅为O（1）。



\>> 通过使用SDS而不是C字符串，Redis将获取字符串长度所需的复杂度从O（N）降低到了O（1），这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。例如，因为字符串键在底层使用SDS来实现，所以即使我们对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响，因为STRLEN命令的复杂度仅为O（1）。



字符串重新赋值涉及内存分配，为避免频繁地内存分配，预申请一定大小内存空间，并记录未使用数量，类似于golang中的slice

\>> 在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。

通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。



\>> 额外分配的未使用空间数量由以下公式决定：

❑如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。

❑如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。

通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。



\>> 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

举个例子，sdstrim函数接受一个SDS和一个C字符串作为参数，移除SDS中所有在C字符串中出现过的字符。

比如对于图2-14所示的SDS值s来说，执行：



图2-14 执行sdstrim之前的SDS


 sdstrim(s, "XY"); //移除SDS字符串中的所有'X'和'Y'

会将SDS修改成图2-15所示的样子。



图2-15 执行sdstrim之后的SDS

注意执行sdstrim之后的SDS并没有释放多出来的8字节空间，而是将这8字节空间作为未使用空间保留在了SDS里面，如果将来要对SDS进行增长操作的话，这些未使用空间就可能会派上用场。





## 1.2 链表



Redis列表数据结构

\>> listNode结构组成的链表。





## 1.3 字典

Redis字典实现，就是个hashmap

字典rehash操作满足装填因子限制，rehash存储空间再分配，再分配空间大小根据扩张和收缩来决定，前者为大于当前key数量两倍的第一个2的幂，后者为第一个大于key数量的2的幂。

\>> 随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：

1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：

❑如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）；

❑如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。

2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。



渐进式rehash操作

\>> 渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

## 1.4 跳跃表

相比于保持平衡树的平衡，跳表代价要小，对于存储元素数量比较多或者键值比较代价比较高这两种会显著加长树平衡调整时间的因素，考虑减少这部分调整时间，就可以采用跳表。

\>> 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。



其实跳表还不能直接说成是对二叉查找树的优化，它其实是对链表或者数组链表的优化，链表的查找时间复杂度为O（n），为了加速查询，吸取了二叉查找树索引节点缩小查找范围的优势。本质上跳表还是一个链表，只是链表中每个节点在生成的时候，按照一定的规则，生成不同level的索引节点指针，生成level的层数是一个概率值指定的，可以参考github上go相关跳表的开源实现。

\>> 跳跃表的实现

Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。

## 1.5 整数集合

整数集合的实现，希望通过同一种数据结构来保存不同位宽的整数值，如果直接使用int64表示数组元素类型，太浪费空间，可能存储的元素是int16。为了节省空间，在整数集合结构体里面加一个字段encoding来表示数组元素的位宽，content元素类型虽然是int8，但是实际上是将encoding中指定的类型拆成高低位进行存储，元素数量有length指定。如果开始存储元素类型为int16，内存分配时按照每个元素16位进行计算、分配，后面存储64位元素时，会对content进行升级，将所有元素类型提升为64，这就要重新计算存储空间大小。但是删除位宽大的元素，不会触发降级。

\>> 整数集合的实现

整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。

每个intset.h/intset结构表示一个整数集合：


 typedef struct intset {
​     //编码方式
​     uint32_t encoding;
​     //集合包含的元素数量
​     uint32_t length;
​     //保存元素的数组
​     int8_t contents[];
 } intset;





## 1.6 压缩列表

\>> Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update），图7-13展示了这一过程。

## 1.7 对象

Redis中zset存储元素时，绝大多数场景下用的是跳表，只有存储场景满足这两个条件时才会用压缩列表，应该比较少见，或者初期是压缩列表，后面变更为跳表。

\>> 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

❑有序集合保存的元素数量小于128个；

❑有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序集合对象将使用skiplist编码。



\>> 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

❑有序集合保存的元素数量小于128个；

❑有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序集合对象将使用skiplist编码。

# Part 2 日常操作

Redis数据库、rdb持久化、aof持久化、事件、客户端、服务器

## 2.1 数据库操作

Redis过期键删除策略，有一个字典记录了每一个键的过期时间，或者定时删除（耗CPU），惰性删除（耗内存），定期删除（折中方案，但是定期间隔把握不好也会造成耗CPU和内存）。

\>> 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。

❑惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。

❑定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。



rdb备份模式不会存储过期键

\>> 生成RDB文件

在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。



aof模式下操作流水都会落地磁盘，没必要这个时候来删除过期键，等后续惰性删除触发或者主动删除时，显示地来记录一条删除流水代价更小。

\>> AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。



\>> AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。



\>> 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：

1）从数据库中删除message键。

2）追加一条DEL message命令到AOF文件。

3）向执行GET命令的客户端返回空回复。



Redis工作在复制模式下时，从节点对不对过期键做删除操作，删除动作完全由主节点控制并通知从节点，这样可以保证主从节点的数据一致性！

\>> 复制

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：

❑主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。

❑从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。

❑从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。



键空间通知，键事件通知！

\>> 这一类关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification），除此之外，还有另一类称为键事件通知（key-event notification）的通知，它们关注的是“某个命令被什么键执行了”。



对Redis 键过期删除模式进行适当设置，比如定时删除，结合这里的事件通知，是否可以实现一个高精度的分布式定时器呢？

\>> 关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。



\>> 9.8.1 发送通知

发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的：


 void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);

函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。

event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。

## 2.2 rdb持久化

用的什么压缩算法呢？

\>> RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，

## 2.3 aof持久化

# Part 3 高可用

Redis复制、sentinel监控、集群

## 3.1 复制功能

### 3.1.1 旧版Redis实现（小于v2.8)

旧版本的Redis（小于v2.8）的复制功能实现，分为“**同步（sync）**”和“**命令传播（command propagate）**”两个操作：

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

#### 复制之“同步”操作

主从节点复制之同步操作工作过程：

当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：

1. 从服务器向主服务器发送SYNC命令。
2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

#### 复制之“命令传播”

为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：

- 主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行；
- 当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

#### 旧版复制功能的缺陷

在Redis中，从服务器对主服务器的复制可以分为以下两种情况：

- 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。

- 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

旧版Redis从节点断线重连后重新执行sync执行复制，这个时候主节点还是把整个rdb文件丢给从节点，但是其中的多数数据从节点可能已经记录下来了，因此这种复制方式是低效的。新版本Redis通过心跳机制来上报从节点当前的“**复制偏移量**”，主节点根据从节点心跳上报的复制偏移量来决定从哪个位置开始命令传播，这种“**增量**”处理的方式更加友好。

### 3.1.2 新版Redis实现

#### 复制之“同步”操作

新版本的Redis的同步包括了两部分，“**全同步**”和“**部分同步**”：

- 全同步：这种方式类似于旧版本的“同步”操作；
- 部分同步：这种方式是利用了从节点心跳上报的复制偏移量，实现增量同步。

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。

PSYNC命令具有“**完整重同步（full resynchronization）**”和“**部分重同步（partial resynchronization）**”两种模式：

##### 完整重同步

用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。

##### 部分重同步

则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

##### 复制积压缓冲区与同步的关系

部分重同步功能由以下三个部分构成：

- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。

- 主服务器的复制积压缓冲区（replication backlog）。

- 服务器的运行ID（run ID）

Redis复制积压缓冲区，它是一个默认大小1MB的队列（队列定长，如果队列满，后续新命令入队会冲掉队首元素），里面记录了每个要操作的命令，还有一个数据结构维护了命令中各个字符对应的复制偏移量，用来跟从节点做部分同步用。因为队列大小有限（大小可配置），可能会满，此时会将队首几个写命令对应的字符移除。这样从节点的复制偏移量与主节点就不一致了，主节点检测到从节点的偏移量对应的数据已经不在积压缓冲区了，就会和从节点进行全量同步。如果从节点的复制偏移量数据还在主节点的积压缓冲区里面，就执行部分同步！

举个例子，如果我们要将'h'、'e'、'l'、'l'、'o'五个字符放进一个长度为3的固定长度先进先出队列里面，那么'h'、'e'、'l'三个字符将首先被放入队列：['h'，'e'，'l’]，但是当后一个'l'字符要进入队列时，队首的'h'字符将被弹出，队列变成：['e'，'l'，'l’]，接着，'o'的入队会引起'e'的出队，队列变成：['l'，'l'，'o’]。

因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：

- 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。

- 相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。

##### 节点运行id与同步的关系

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：

- 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。

- 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

#### 命令传播

主从节点保持数据一致性的做法是，一个是会定期地做同步处理，再一个是同步之后，主节点会向从节点广播刚刚执行过的写命令，从节点响应写命令。通过这两种方式来尽可能保证主从节点数据一致性。但是由于主从节点以及网络故障，还需要其他的机制来保证，如主从节点掉线后的重同步，或者命令丢失引起的主从节点ack的复制偏移量同步。命令传播给子节点如果所有子节点没有响应，主节点会拒绝执行该写入命令。

当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。

##### 主从节点之间的心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：`REPLCONF ACK ＜replication_offset＞`，其中replication_offset是从服务器当前的复制偏移量。

该命令对于主从服务器有三个作用：

- 检测主从服务器的网络连接状态。

- 辅助实现min-slaves选项。

- 检测命令丢失。

## 3.2 Sentinel

Sentinel系统负责对Redis主节点、从节点进行监视，并在主节点离线后，进行故障转移failover操作，就是将原先的某个从节点提升为主节点，并让其他从节点从新的主节点开始复制。后续离线的主节点上线后，会降级为新主节点的从节点。

\>> Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。



图16-1 服务器与Sentinel系统

图16-1展示了一个Sentinel系统监视服务器的例子，其中：

❑用双环图案表示的是当前的主服务器server1。

❑用单环图案表示的是主服务器的三个从服务器server2、server3以及server4。

❑server2、server3、server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器。

假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如图16-2所示（下线的服务器用虚线表示）。



图16-2 主服务器下线

当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：

❑首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。

❑之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。

❑另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。



\>> Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。



图16-1 服务器与Sentinel系统

图16-1展示了一个Sentinel系统监视服务器的例子，其中：

❑用双环图案表示的是当前的主服务器server1。

❑用单环图案表示的是主服务器的三个从服务器server2、server3以及server4。

❑server2、server3、server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器。

假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如图16-2所示（下线的服务器用虚线表示）。



图16-2 主服务器下线

当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：

❑首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。

❑之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。

❑另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。



sentinel向主节点从节点发送ping命令，如果预设的时限内节点一直返回无效的回复，sentinel会认为该探测节点是主观下线状态，这个时候sentinel会触发节点是否客观下线的判断。所谓客观，就是作为其他sentinel节点，你们是否认为这个探测节点下线，如果多数认为该探测节点下线，那么该探测节点会被认为确实已下线，sentinel会进而触发故障转移操作。

\>> 检测主观下线状态

在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。



图16-17 Sentinel向实例发送PING命令



\>> 16.7 检查客观下线状态

当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。



sentinel leader选举

\>> 选举领头Sentinel

当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。



\>> 选举领头Sentinel

当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。



\>> 故障转移

在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：

1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。

2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。

3）将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。



sentinel leader从一堆从节点里面选举新的主节点，有几条参考标准，宗旨就是，从节点要在线，并且节点上的数据尽可能是最新的。

\>> 故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。

新的主服务器是怎样挑选出来的

领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：

1）删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。

2）删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。

3）删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds*10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。

之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。

如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并选出其中偏移量最大的从服务器（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。

最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。

## 3.3 集群

cluster meet ip port，将当前节点与IP port标志的节点组建成一个集群，cluster nodes显示当前集群中的节点数量。

\>> 一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。

连接各个节点的工作可以使用CLUSTER MEET命令来完成，该命令的格式如下：


 CLUSTER MEET ＜ip＞ ＜port＞

向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。



\>> 一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。

连接各个节点的工作可以使用CLUSTER MEET命令来完成，该命令的格式如下：


 CLUSTER MEET ＜ip＞ ＜port＞

向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。



cluster meet命令工作流程，节点a与节点b构成一个集群以后，会通过gossip协议通知集群内的其他节点与b握手。

\>> 图17-8 节点的握手过程

之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。



Redis集群对数据的存储是通过slots进行进行管理的，集群上线之前必须将所有的slots指派给集群中的节点进行处理，否则集群处于离线状态。

\>> 在集群中执行命令

在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。

当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：

❑如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。

❑如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。

图17-18展示了这两种情况的判断流程。



图17-18 判断客户端是否需要转向的流程



\>> 在集群中执行命令

在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。

当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：

❑如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。

❑如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。

图17-18展示了这两种情况的判断流程。



图17-18 判断客户端是否需要转向的流程





# Part 4 高阶技能



\>> 独立功能的实现

第18章 发布与订阅

第19章 事务

第20章 Lua脚本

第21章 排序

第22章 二进制位数组

第23章 慢查询日志

第24章 监视器

◆ 第19章 事务



Redis事务

\>> Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

以下是一个事务执行的过程，该事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交（commit）给服务器执行：



Redis事务处理三个阶段

\>> 事务的实现

一个事务从开始到结束通常会经历以下三个阶段：

1）事务开始。

2）命令入队。

3）事务执行。



multi命令开启一个新的事务

\>> 事务开始

MULTI命令的执行标志着事务的开始：


 redis＞ MULTI
 OK

MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的，MULTI命令的实现可以用以下伪代码来表示：


 def MULTI():
 \#打开事务标识
 client.flags |= REDIS_MULTI
 \#返回OK回复
 replyOK()



事务模式下，Redis命令入队。客户端处于非事务模式下，客户端发送给服务端的命令被立即执行；当客户端处于事务模式下，发送给服务端的命令不会立即执行，而是被存到一个事务命令队列里面，回一个queued给客户端。

\>> 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行：


 redis＞ SET "name" "Practical Common Lisp"
 OK
 redis＞ GET "name"
 "Practical Common Lisp"
 redis＞ SET "author" "Peter Seibel"
 OK
 redis＞ GET "author"
 "Peter Seibel"

与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

❑如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。

❑与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。

服务器判断命令是该入队还是该立即执行的过程可以用流程图19-1来描述。



图19-1 服务器判断命令是该入队还是该执行的过程



\>> 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行：


 redis＞ SET "name" "Practical Common Lisp"
 OK
 redis＞ GET "name"
 "Practical Common Lisp"
 redis＞ SET "author" "Peter Seibel"
 OK
 redis＞ GET "author"
 "Peter Seibel"

与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

❑如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。

❑与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。

服务器判断命令是该入队还是该立即执行的过程可以用流程图19-1来描述。



图19-1 服务器判断命令是该入队还是该执行的过程



exec命令，服务端会依次执行之前事务中入队的命令，并执行并返回结果。

\>> 执行事务

当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。



watch命令用来监视Redis的一个或者多个键值，watch命令利用一个链表来记录被监视的键，每个被监视的键又记录了一个watch该键的客户端列表。当某个键被一个客户端执行了写操作时，将检查该键有没有被watch，如果有，则会将监视该键的Redis dirty flag标记为打开。如果这些标记被打开的客户端正在准备执行事务操作，当他们命令入队结束发送exec命令时，服务端将开始执行事务，但是实际执行之前会先检查该客户端的Redis dirty flag是否打开，如果没打开，好，执行事务即可，如果已经打开了，表示该客户端的事务安全性已经被破坏了，拒绝执行事务。非常简单粗暴，和MySQL MVCC比起来简单粗暴很多。

\>> WATCH命令的实现

WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。



\>> WATCH命令的实现

WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。



Redis中事务的acid特性，前面提到watch命令能用来保证事务执行的安全性，假如事务开始时dirty cas标志没打开，事务开始执行，事务执行中间却突然有另一个客户端执行了某个Redis操作会破坏当前客户端的事务安全性？其实不存在这种情况，Redis是单进程模型。

\>> 在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。



\>> 在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。



事务原子性，事务中的命令要么都执行，要么都不执行。如果命令入队过程中，有命令入队失败，则事务拒绝执行。如果命令入队过程中入队成功，但是入队的命令其实是有问题的，这个时候事务执行过程中遇到错误也会继续执行，只是这个有问题的命令返回的是错误，但是从事务这个层面来讲，确实所有的事务命令都执行了，它完成了预设的动作。MySQL事务遇到错误可以回滚，Redis不支持，为啥，因为事务回滚需要额外的一些措施保证，与Redis简单高效的设计初衷不符，而且作者坚定的认为Redis事务操作中出现类似的命令执行失败的情况，绝逼是编程错误引起，如果有足够测试一定会在测试阶段就能发现。

\>> 原子性

事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。

对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此，Redis的事务是具有原子性的。



\>> 原子性

事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。

对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此，Redis的事务是具有原子性的。



命令入队时错误检查，命令执行时错误检查，事务执行过程中宕机。这三种情况下都Redis都可以保证数据的一致性。可能有人问咋可能，宕机了咋还可能一致？这里需要理解一致的含义，一致性并不是指的可靠性，也不是可用性，它强调的是存储数据本身的状态。对Redis事务一致性而言，它强调的是事务执行结果是否能可靠的落地磁盘，rdb, aof…，如果宕机时事务执行完但没落地，那么恢复时沿用上次的rdb aof文件，只是丢失了上次的事务操作结果，Redis本身的数据是完整的、干净的。考虑到这里没落地成功的事务对业务的影响，可以引入适当的对账机制来解决。

\>> 一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三个小节将分别介绍三个Redis事务可能出错的地方，并说明Redis是如何妥善地处理这些错误，从而确保事务的一致性的。



\>> 一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三个小节将分别介绍三个Redis事务可能出错的地方，并说明Redis是如何妥善地处理这些错误，从而确保事务的一致性的。



Redis是单进程模型并且事务执行期间不会被其他事务中断，因此隔离性总是有保证的。

\>> 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。



\>> 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。



只有在aof模式下，并且appendfsync选项为true时，Redis耐久性才有保证，其他的都不能保证。

\>> 耐久性

事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。

因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定：

❑当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。

❑当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。



\>> 耐久性

事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。

因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定：

❑当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。

❑当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。

❑当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。





◆ 第23章 慢查询日志



Redis慢查询日志

\>> Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。

服务器配置有两个和慢查询日志相关的选项：

❑slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。

举个例子，如果这个选项的值为100，那么执行时间超过100微秒的命令就会被记录到慢查询日志；如果这个选项的值为500，那么执行时间超过500微秒的命令就会被记录到慢查询日志。

❑slowlog-max-len选项指定服务器最多保存多少条慢查询日志。

服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。

举个例子，如果服务器slowlog-max-len的值为100，并且假设服务器已经储存了100条慢查询日志，那么如果服务器打算添加一条新日志的话，它就必须先删除目前保存的最旧的那条日志，然后再添加新日志。



\>> Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。

服务器配置有两个和慢查询日志相关的选项：

❑slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。

举个例子，如果这个选项的值为100，那么执行时间超过100微秒的命令就会被记录到慢查询日志；如果这个选项的值为500，那么执行时间超过500微秒的命令就会被记录到慢查询日志。

❑slowlog-max-len选项指定服务器最多保存多少条慢查询日志。

服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。

举个例子，如果服务器slowlog-max-len的值为100，并且假设服务器已经储存了100条慢查询日志，那么如果服务器打算添加一条新日志的话，它就必须先删除目前保存的最旧的那条日志，然后再添加新日志。



Redis慢查询日志相关设置、查看命令

\>> CONFIG SET slowlog-log-slower-than 0
 OK
 redis＞ CONFIG SET slowlog-max-len 5
 OK

接着，我们用客户端发送几条命令请求：


 redis＞ SET msg "hello world"
 OK
 redis＞ SET number 10086
 OK
 redis＞ SET database "Redis"
 OK

然后使用SLOWLOG GET命令查看服务器所保存的慢查询日志：


 redis＞ SLOWLOG GET
 1) 1)（integer） 4                #日志的唯一标识符（uid）
​    2) (integer) 1378781447        #命令执行时的UNIX时间戳
​    3) (integer) 13                #命令执行的时长，以微秒计算
​    4) 1) "SET"                    #命令以及命令参数
​       2) "database"
​       3) "Redis"



\>> CONFIG SET slowlog-log-slower-than 0
 OK
 redis＞ CONFIG SET slowlog-max-len 5
 OK

接着，我们用客户端发送几条命令请求：


 redis＞ SET msg "hello world"
 OK
 redis＞ SET number 10086
 OK
 redis＞ SET database "Redis"
 OK

然后使用SLOWLOG GET命令查看服务器所保存的慢查询日志：


 redis＞ SLOWLOG GET
 1) 1)（integer） 4                #日志的唯一标识符（uid）
​    2) (integer) 1378781447        #命令执行时的UNIX时间戳
​    3) (integer) 13                #命令执行的时长，以微秒计算
​    4) 1) "SET"                    #命令以及命令参数
​       2) "database"
​       3) "Redis"





◆ 第24章 监视器



Redis客户端可以通过执行monitor命令变成一个监视器，来监视Redis服务端执行的命令。

\>> 通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息：


 redis＞ MONITOR
 OK
 1378822099.421623 [0 127.0.0.1:56604] "PING"
 1378822105.089572 [0 127.0.0.1:56604] "SET" "msg" "hello world"
 1378822109.036925 [0 127.0.0.1:56604] "SET" "number" "123"
 1378822140.649496 [0 127.0.0.1:56604] "SADD" "fruits" "Apple" "Banana" "Cherry"
 1378822154.117160 [0 127.0.0.1:56604] "EXPIRE" "msg" "10086"
 1378822257.329412 [0 127.0.0.1:56604] "KEYS" "*"
 1378822258.690131 [0 127.0.0.1:56604] "DBSIZE"

每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器，如图24-1所示。



图24-1 命令的接收和信息的发送





