
#### 题目
给一个指定的int数组，要求从数组中删除所有的与指定数值相等的元素，例如数组[ 1 2 2 3 2 5 ]，要求删除所有的2得到数组[1 3 5]，另外呢？这里的删除操作必须“**原地进行**”，即在原数组中删除。

##### 如果允许开辟新数组

如果允许开辟新数组那就简单多了，可以直接遍历数组，如果元素与指定要删除的值不相等则将元素放入新数组。

```c
void remove_element(int A[], int len, int value, int _A[], int *_len) {
    int i = 0;
    int j = 0;
    for(; i < len; i++) {
        if(A[i] == value)
            continue;
            
        _A[j++] = A[i];
    }
    *_len = j;
}
```

这种方式是比较简单的，但是对内存的消耗比较大，特别是如果数组A[]比较大而待删除的元素出现又比较少的时候，基本上相当于完全复制了一个数组的空间。

##### 如果不允许开辟数组

不允许开辟新数组，实际上正是考虑到如何通过高效的算法避免对内存空间的浪费。

以数组[ 1 2 2 3 2 4 ]为例，删除所有的元素至少要遍历一遍数组，遍历时需要一个变量“**i**”来记录下当前在数组中的位置，遍历的过程中如果碰到A[i]等于要删除的值，我们可以考虑将后续的元素前移一个位置，但是这样的算法时间复杂度基本上O(n^(2))级别的。

这里的问题实际上在于变量“**i**”既被用来记录待删除的元素，又被用来记录数组遍历的位置，如果再借助另一个变量“**j**”来分摊变量“**i**”的一个用途是不是可以改善里的算法？

现在我们让变量i、j同时参与数组遍历，当碰到待删除的元素时，我们用变量j记录待删除元素的位置，变量i继续遍历直到遇到非待删除的元素，可以看到[j,i)之间的所有元素都是待删除的元素，此时直接将A[i]赋值给A[j]，变量j++，变量j此时表示的也正是新数组的长度。通过对算法流程进行验证，算法准确无误。

```c
void remove_element(int A[], int len, int value, int *_len) {
    int i = 0;
    int j = 0;
    for(; i < len; i++) {
        if(A[i] == value)
            continue;

        A[j] = A[i];
        j++;
    }
    
    *_len = j;
}
```





