前一阵子，在某厂笔试题（Java）里面，出现了这样一个考题：

```c
    int a = 0;
    a += (a++) + (++a);
```
上述两条语句执行之后，a的值是多少？ 

这么简单的题目也需要考吗，这太简单了吧？知道怎么算是一回事， 明不明白是另一回事！而且不一定会算吧！

【备注】
如果不是脑子有病，估计不会有人写这样的程序，那解释这道题有什么意义呢？确实，有很多更加值得折腾的东西，比如中间件、智能算法等等，相比起来，去钻研这种编程题太没意思了，出题人脑残还是咋滴，对此，我绝对同意。但是除了这种想法的人外，也确实有一部分人，想人所不想，能人所不能，你总不能说他们求知是个错误吧！今天，刚好有人问起，我就顺便回答了一下，然后整理了整理。
感兴趣的话就耐心往下看吧，也不长，估计应该能看懂。

以前给红黑联盟里一帮小朋友解答过c里面前置增后置增的实现问题，没想到今天又在一个Java高级群里面碰到了群友问相同的问题，区别是java中的实现方式。其实，说白了，这些是编译原理层面的知识，也需要对内存模型有一定的理解，尤其要注意JMM。但是一般情况下我相信是没有几个人是愿意去翻gcc、javac的设计、实现的。那怎么办？
了解一下基本的内存模型，反汇编，可能还是比较实用的一种办法。

**1）c，编译器gcc**
```c
int main(int argc, char *argv[]){  
    4004f6:       55                      push   %rbp  
    4004f7:       48 89 e5                mov    %rsp,%rbp  
    4004fa:       89 7d ec                mov    %edi,-0x14(%rbp)  
    4004fd:       48 89 75 e0             mov    %rsi,-0x20(%rbp)        
        int a = 0;  
    400501:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp) // 给a赋值0        
        a += (a++)+(++a);
    400508:       8b 45 fc                mov    -0x4(%rbp),%eax // a++中初始装载变量a到eax
    40050b:       8d 50 01                lea    0x1(%rax),%edx             
    40050e:       89 55 fc                mov    %edx,-0x4(%rbp) // lea将1+rax的值存储回变量a（变量a的值变为1），但是不修改rax的值。
                                                                                            // 使用的是lea，而非add，为啥？后置增，rax记录着a自增之前的旧值！
                                                                                            // 后置增，即使用后+1，这里的”使用后“，指的是执行整条语句之后吗？ 不是！
    400511:       83 45 fc 01             addl   $0x1,-0x4(%rbp) // ++a操作（变量a的值变为2）
    400515:       8b 55 fc                mov    -0x4(%rbp),%edx             
    400518:       01 d0                   add    %edx,%eax       // 执行 (a++) + (++a)操作，即0+2，并将结果暂存到eax
    40051a:       01 45 fc                add    %eax,-0x4(%rbp) // 执行a+=...，即2+2并将结果存储到变量a（变量a的值变为4）
        return 0;  
    40051d:       b8 00 00 00 00          mov    $0x0,%eax}
```

看完上面的解释后，你应该能总结处这样的规律，(a++) + (++a)中，a++是先于++a执行的，即普通的表达式一般都是从左向右进行运算，另外你也应该记住lea指令的用法，在这里还不失巧妙。

**2）java，编译器javac**
看懂了c的就懂java的吗？不一定！c里面跑出来的结果是a=4，但是java呢？是2！怎么可能不一样？还真就是不一样。

```java
Compiled from "T.java"
Compiled from "T.java"class T {  T();    
Code:       
0: aload_0              
1: invokespecial #1                  // Method java/lang/Object."<init>":()V       
4: return        

  public static void main(java.lang.String[]);    
 Code:
   int a = 0;        
0: iconst_0                   // iconst_0字节码指令，将整数0压入线程栈中        
1: istore_1                   // istore_1指令，从线程栈中弹出一个整数（0），并将其写入到编号为1的局部变量中，完成a初始化
  a += (a++) + (++a);        
2: iload_1                    // iload_1指令，装载编号为1的局部变量（a）的值，并压栈，记为n1（a++中的a被装载，n1=0）       
3: iload_1                    // iload_1指令，装载编号为1的局部变量（a）的值，并压栈，记为n2（++a中的a被装载，n2=0）       
4: iinc          1, 1          // iinc指令，将编号为1的局部变量（a）的值+1（a的值变为1，n1、n2不变）       
7: iinc          1, 1          // iinc指令，将编号为1的局部变量（a）的值+1（a的值变为2，n1、n2不变）      
10: iload_1                  // iload_1指令，装载编号为1的局部变量（a）的值，并压栈，记为n3（a += ... 中的a被装载）      
11: iadd                       // 现在操作数栈中，依次是操作数2、0、0，iadd弹栈2次，并将2+0的结果重新入栈
    12: iadd                       // iadd再弹栈两次，并将2+0的结果重新入栈       
13: istore_1                 // istore_1执行弹栈，得到结果2，并将结果存储到编号为1的局部变量中，a += (a++)+(++a)执行结束                      
14: return        
}
```

我觉得解释的足够详细了，如果对于java的这部分还是不能理解呢，那应该看一下java内存模型，主存、线程工作内存之间的关系，有必要的话，还应该了解一下read、load、use、assign、store、write等操作以及他们之间的happens-before关系。

我是不希望看到有人在问（我）类似的问题了，再有人问，就让他来翻我的qq空间吧。