# 1 指令重排序

## 1.1 什么是指令重排序？

指令重排序，指的是为了提高程序执行效率，编译器会对生成的执行进行“**编译时重排序**”优化以提高寄存器利用率，CPU流水线设计也会为了实现更高的吞吐量对待执行的指令进行“**运行时重排序**”。这里重排序的对象是**相互之间没有数据依赖关系的访存指令（LOAD/STORE指令）。

## 1.2 编译时指令重排序

在程序编译的时候，为了**最大化对寄存器的利用率**，以便提高程序运算速度，编译器会对编译后得到的指令进行重排序，称为编译时重排序。

某些情况下，开发人员希望阻止编译时指令重排序来满足某种特殊的需求，这个时候开发人员需要显示插入特殊的代码来告知编译器不要做指令重排的优化。例如，**在内核里面通过barrier()来达到阻止编译时指令重排序的目的，barrier在内核里面其实是通过一个宏定义来实现的,即:`#define barrier() asm volatile("":::"memory")`，这里的指令破坏部告知内存数据可能被修改，因此需要对访存逻辑进行严格控制，编译器不要做访存指令重排的优化动作**。

下面举个例子说明下为什么会有阻止编译时指令重排的需求，这里阻止指令重排的手段是通过内联汇编创建内存屏障。

这个例子中，假定我们要按照某中特定的顺序访问一块内存，这里的内存区域是通过统一编址方式、Memory Mapped IO来对外设进行访问，而不是一块实实在在的内存。对这个内存区域的访问会被转换成对外设的访问。我们需要告诉编译器不要做指令重排的优化，否则编译器追求效率优化后我们可能会得到错误的结果。
假定我们要自增这个内存地址`d[0]+=1`，然后读取一点信息`r = e[0]`，然后再自增一个相邻地址出的值`d[1] += 1`，示例代码如下：

```c
int c(int *d, int *e) {
       int r;
       d[0] += 1;
       r = e[0];
       d[1] += 1;
       return r;
}
```

默认地，gcc会追求更好的性能而对访存操作进行优化，实际编译、重排后的指令可能是这样的：

```c
00000000 <c>:
  0:   4603        mov r3, r0
  2:   c805        ldmia   r0, {r0, r2}
  4:   3001        adds    r0, #1
  6:   3201        adds    r2, #1
  8:   6018        str r0, [r3, #0]
  a:   6808        ldr r0, [r1, #0]
  c:   605a        str r2, [r3, #4]
  e:   4770        bx  lr
```
上述d[0]、d[1]的值是同时加载的，虽然这个示例代码中是无害的，但是如果我们要避免这种情况，可以通过内存屏障来告知编译器不要做这种指令重排的优化：

```c
int c(int *d, int *e) {
       int r;
       d[0] += 1;
       r = e[0];
       asm volatile("" ::: "memory");
       d[1] += 1;
       return r;
}
```
这次gcc处理后的指令编程了下面这样，可以看到adds和str指令没有再被重排了:

```c
00000000 <c>:
  0:   6802        ldr r2, [r0, #0]
  2:   4603        mov r3, r0
  4:   3201        adds    r2, #1
  6:   6002        str r2, [r0, #0]
  8:   6808        ldr r0, [r1, #0]
  a:   685a        ldr r2, [r3, #4]
  c:   3201        adds    r2, #1
  e:   605a        str r2, [r3, #4]
 10:   4770        bx  lr
 12:   bf00        nopIt
```
**需要注意的是，这只是在编译时阻止了指令重排，对运行时CPU如何重排无能为力。实际在运行时，如果CPU支持指令流水线设计，指令之间没有数据依赖关系，指令访存地址是正常内存地址而非strong-ordered或者device，CPU也是会为了追求更高吞吐量而对指令进行重排的。**

## 1.3 运行时指令重排序

在程序被执行时，处理器采用流水线技术对指令进行读取、指令翻译、访存、io、运算等任务，但是其中的某些指令有可能会出现阻塞后续指令执行的情况，例如缓存不命中的情况下，就需要从内存加载数据到缓存，很耗时间，那么就会考虑将后续的指令提前先执行；还有的就是为了充分利用缓存，提高缓存的利用率，也会考虑将内存地址临近的数据进行读取。

在上述处理过程中，就会涉及到相关的指令在运行时重排序的问题，称为运行时重排序，开发人员对此是无能为力的。

## 1.4 约束

不管是编译时指令重排序，还是运行时指令重排序，必须要保证重排序后的指令执行后的效果，与串行执行后的效果相同，否则就会违背程序执行的“**顺序一致性**”。但是这里的顺序一致性，编译器可能会误判并采取某些我们认为的激进的优化而导致错误的结果，所以编译时指令重排是每个开发人员应该认识到、理解并掌握的技术点。