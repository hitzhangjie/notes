在java里面不用显示的释放对象（如c++需要显示地delete释放堆内存对象），在java里面对象失去引用关系后，会自动被gc回收。这里就涉及到java的自动内存回收机制。

首先在java里面，定义了几种引用类型：

- 强引用，这种引用类型在程序代码中是普遍存在的，例如Object obj = new Object()，只要obj没有被设置成null，那么obj指向的对象是永远不会被gc进行回收的；
- 软引用，SoftReference，这种引用关系用于描述有用但是非必须的引用关系，当jvm中进行了minor gc，发现剩余内存不够用，然后就会进行full gc，full gc后发现还不够用的时候，才会抛出OutOfMemoryError。而这里的软引用引用的对象，可以在gc抛出OutOfMemoryError之前，被列入待回收对象范围，然后进行回收。
- 弱引用，WeakReference，这种引用关系描述的是非必须的引用关系，当jvm进行gc的时候，一定会回收弱引用所引用的对象内存空间。
- 虚引用，PantomReference，这种引用没什么特别用处，但是当对象被回收的时候可以获得一个通知。

然后需要考虑，jvm如何发现失去引用关系的对象，一种是基于对象的引用计数法的，这在操作系统里面也广泛使用，但是在java里面，引用计数法不能解决环形依赖的问题，比如：

```java
class B {
    A a;
    public void setA(A a) { this.a = a; }
}
class A {
    B b;
    public void setB(B b) { this.b = b; }
}
B b = new B();
A a = new A();
b.setA(a);
a.setB(B);
```

这样a和b相互依赖，假如现在a、b的作用域已经到头了，然后变量a、b被销毁了，但是在a所引用的对象里面还引用着对象b引用的对象，在b引用的对象里面还继续引用着a引用的对象，即虽然栈变量a、b不存在了，但是由于堆上的两个对象存在**环形依赖**问题。

这两个对象，如果是按照引用计数法来判断的话，都存在引用关系，是活的对象，无法进行回收；

**jvm里面的垃圾回收，必须要解决判断对象是否存活的问题，采用的是基于GC Roots链的可达性分析算法，即通过可以作为GC Roots的对象进行可达性分析，无法到达的对象就被视为待回收对象，除非在第一次标记之后，第二次标记之前，通过finalize方法成功拯救了自己，即重新建立this与外部某个变量的引用关系。**

可以作为**GC Roots的对象**包括：

- 虚拟机栈（栈帧中的本地变量表）中变量引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（即一般所说的native方法）引用的对象；

**通过GC Roots对象，及其成员变量所引用的对象，……，我们可以得到一条链，叫做GC Roots链，在这条链上的对象，表示对象可达，是活的，如果是强引用则不会被回收，软引用要视情况而定，弱引用一定会被回收。**

那么是否应该提出另一个疑问？jvm中如何通过对象的引用变量，来定位对象在内存的位置。这里涉及到**对象的访问定位，主要包括两种方式，通过句柄访问对象、通过直接指针访问对象**。关于什么是通过句柄访问对象、什么是通过直接指针访问对象，请参见jvm中相关内容进行详细地了解，这里不再赘述。

